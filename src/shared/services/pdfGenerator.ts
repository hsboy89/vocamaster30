import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { Word, Level, LEVEL_INFO, CATEGORY_INFO, Category } from '../types';

// ==========================================
// Font Loading Helper
// ==========================================
// Noto Sans KR (Regular) - Public URL or hosted asset

async function loadKoreanFont(doc: jsPDF) {
    try {
        // Using a reliable source for a Korean TTF file.

        // Let's try to use the system font if possible? No, PDF needs embedded font.
        // We will use a fallback approach: 
        // If we can't easily fetch a font, we might need the user to provide one. 
        // But to be helpful, let's try a standard one.

        // Using a reliable source for a Korean TTF file.
        // NanumGothic is often used.
        const fontUrl = 'https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Regular.ttf';

        // Optimization: Check if font is already added? jsPDF doesn't have a simple check API, but we can manage a global flag if needed.
        // For now, let's fetch.
        const res = await fetch(fontUrl);
        if (!res.ok) throw new Error('Failed to load font');
        const buffer = await res.arrayBuffer();

        // Convert to binary string for jsPDF
        const fontData = new Uint8Array(buffer);
        let binaryString = "";
        for (let i = 0; i < fontData.length; i++) {
            binaryString += String.fromCharCode(fontData[i]);
        }

        // Add to VFS
        doc.addFileToVFS('NanumGothic-Regular.ttf', binaryString);
        doc.addFont('NanumGothic-Regular.ttf', 'NanumGothic', 'normal');
        doc.setFont('NanumGothic');

        return true;
    } catch (error) {
        console.error('Font loading failed:', error);
        return false;
    }
}

// ==========================================
// PDF Generation Functions
// ==========================================

export async function generateDayVocaPDF(
    level: Level,
    day: number,
    words: Word[],
    category?: Category | null,
    mode: 'study' | 'test' = 'study'
) {
    const doc = new jsPDF();

    // 1. Load Font
    const fontLoaded = await loadKoreanFont(doc);
    if (!fontLoaded) {
        alert('한글 폰트 로드에 실패했습니다. PDF에 한글이 깨질 수 있습니다.');
    }

    const levelName = LEVEL_INFO[level].nameKo;
    let title = category
        ? `${levelName} - ${CATEGORY_INFO[category].nameKo}`
        : `${levelName} - Day ${day}`;

    // Append mode to title for file name differentiation
    const modeSuffix = mode === 'study' ? '암기장' : '시험지';
    const displayTitle = `${title} - ${modeSuffix}`;

    // Common Header Function
    const addHeader = (doc: jsPDF, pageTitle: string) => {
        doc.setFontSize(18);
        doc.text(pageTitle, 14, 20);
        doc.setFontSize(10);
        doc.text(`Generated by VocaMaster30 | ${new Date().toLocaleDateString()}`, 14, 28);
        doc.text(`Total Words: ${words.length}`, 140, 28);
    };

    // ==========================================
    // Mode: STUDY (Word | Meaning)
    // ==========================================
    if (mode === 'study') {
        addHeader(doc, displayTitle);

        const tableColumn = ["Check", "Words", "Meaning"];
        const tableRows: any[] = [];

        words.forEach(word => {
            const wordData = [
                "  ", // Checkbox placeholder
                word.word,
                word.meaning
            ];
            tableRows.push(wordData);
        });

        autoTable(doc, {
            head: [tableColumn],
            body: tableRows,
            startY: 35,
            styles: {
                font: 'NanumGothic',
                fontSize: 10,
                cellPadding: 3,
            },
            headStyles: {
                fillColor: [63, 81, 181], // Blue color
                textColor: 255,
                fontStyle: 'normal',
            },
            columnStyles: {
                0: { cellWidth: 20, halign: 'center', valign: 'middle' }, // Check
                1: { cellWidth: 60, fontStyle: 'normal', valign: 'middle' }, // Words
                2: { cellWidth: 'auto', valign: 'middle' }, // Meaning
            },
            theme: 'grid',
        });
    }

    // ==========================================
    // Mode: TEST (Blank Meaning & Blank Word)
    // ==========================================
    if (mode === 'test') {
        // Page 1: Meanings Blank
        addHeader(doc, `${title} - 뜻 테스트`);

        const testRowsMeaning: any[] = [];
        words.forEach(word => {
            testRowsMeaning.push(["  ", word.word, " "]); // Meaning is blank
        });

        autoTable(doc, {
            head: [["Check", "Words", "Meaning (Write here)"]],
            body: testRowsMeaning,
            startY: 35,
            styles: { font: 'NanumGothic', fontSize: 10, cellPadding: 3 },
            headStyles: { fillColor: [233, 30, 99], textColor: 255, fontStyle: 'normal' }, // Pink
            columnStyles: {
                0: { cellWidth: 20, halign: 'center', valign: 'middle' },
                1: { cellWidth: 60, fontStyle: 'normal', valign: 'middle' },
                2: { cellWidth: 'auto', valign: 'middle' }
            },
            theme: 'grid',
        });

        // Page 2: Words Blank
        doc.addPage();
        addHeader(doc, `${title} - 단어 테스트`);

        const testRowsWord: any[] = [];
        words.forEach(word => {
            testRowsWord.push(["  ", " ", word.meaning]); // Word is blank
        });

        autoTable(doc, {
            head: [["Check", "Words (Write here)", "Meaning"]],
            body: testRowsWord,
            startY: 35,
            styles: { font: 'NanumGothic', fontSize: 10, cellPadding: 3 },
            headStyles: { fillColor: [0, 150, 136], textColor: 255, fontStyle: 'normal' }, // Teal
            columnStyles: {
                0: { cellWidth: 20, halign: 'center', valign: 'middle' },
                1: { cellWidth: 60, valign: 'middle' },
                2: { cellWidth: 'auto', valign: 'middle' }
            },
            theme: 'grid',
        });
    }

    // Save
    doc.save(`VocaMaster_${title.replace(/\s+/g, '_')}_${modeSuffix}.pdf`);
}
